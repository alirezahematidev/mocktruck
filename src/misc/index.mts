import prettier from "prettier";
import * as cons from "../constants/index.mjs";
import Truck from "../interfaces/index.js";
import { TypeNotation } from "../constants/notations.enum.mjs";
import { faker } from "@faker-js/faker";
// import { TruckArgs } from "../../cli/types/cli.type.mjs";

/**
 * Wraps a synchronous function in an async function that returns a promise
 * which resolves with the result of the synchronous function.
 *
 * @param fn The synchronous function to be wrapped.
 * @returns An async function that returns a promise with the result of the
 *   synchronous function.
 */
export function awaited<P extends any[], R>(
  fn: (...args: P) => R,
): (...args: P) => Promise<R> {
  return async (...args: P): Promise<R> => {
    const result = fn(...args);
    if (result instanceof Promise) {
      return result;
    } else {
      return Promise.resolve(result);
    }
  };
}

/**
 * Returns an array of keys from an object.
 *
 * @param obj The object to retrieve keys from.
 * @returns An array of string keys.
 */
export function getKeys<T extends object>(obj: T): string[] {
  return Object.keys(obj);
}

/**
 * Determines whether an optional object is truthy and non-empty.
 *
 * @param obj The optional object to check.
 * @returns A boolean indicating whether the object is truthy and non-empty.
 */
export function isOptionEnabled<T extends object>(
  obj: T | undefined,
): obj is T {
  return !!obj && getKeys(obj).length !== 0;
}

export function randomKey(length: number) {
  const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_$";

  let result = "";

  for (let i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }

  return result;
}

/**
 * Creates an array of a specified length, populated with values generated by a
 * function.
 *
 * @param length The length of the array to create.
 * @param fn A function that generates the values to populate the array.
 * @returns An array of generated values.
 */
export function list<R extends any>(length: number, fn: (i: number) => R): R[] {
  const array = Array.from({ length }, (_, i) => fn(i));

  return array;
}

/**
 * Appends the ".mts" extension to a filename.
 *
 * @param input The filename to append the extension to.
 * @returns The filename with the ".mts" extension appended.
 */
export function mts(input: string): string {
  return input + ".mts";
}

/**
 * Generates a file URL from a local file path.
 *
 * @param path The local file path to generate the file URL from.
 * @returns The file URL generated from the local file path.
 */
export function meta(path: string): string {
  return "file://" + path;
}

/**
 * Checks whether an array of objects contains any duplicate values for a given
 * field.
 *
 * @param array The array of objects to check.
 * @param field The name of the field to check for duplicates.
 * @returns `true` if the array contains duplicates, otherwise `false`.
 */
export function isDuplicatedField<A extends Array<object>>(
  array: A,
  field: string,
): boolean {
  return !!array.find((obj) =>
    Object.prototype.hasOwnProperty.call(obj, field),
  );
}

/**
 * Generates an ID using a specified strategy.
 *
 * @param strategy The ID generation strategy to use ("uuid" or
 *   "autoincrement").
 * @param index The initial index to use when using the "autoincrement"
 *   strategy.
 * @param increment An optional function that generates the next autoincrement
 *   ID.
 * @returns The generated ID.
 */
export function generateId(
  strategy: "uuid" | "autoincrement",
  index: number,
  increment: () => number = () => index + 1,
): string | number {
  if (strategy === "autoincrement") {
    if (index < 0 || !Number.isInteger(index)) {
      throw new Error("Invalid index: must be a non-negative integer");
    }

    return increment();
  }

  return faker.datatype.uuid();
}

/**
 * Capitalizes the first letter of a string.
 *
 * @param input The string to capitalize.
 * @returns The capitalized string.
 * @throws An error if `input` is not a non-empty string.
 */
export function cap(input: string): string {
  if (typeof input !== "string" || input.length === 0) {
    throw new Error("Input must be a non-empty string");
  }

  return input.charAt(0).toUpperCase() + input.slice(1);
}

/**
 * Transforms the case of a string.
 *
 * @param input The string to transform.
 * @param form The case transformation to apply (lowercase, uppercase,
 *   capitalize). Defaults to no transformation.
 * @returns The transformed string.
 * @throws An error if `input` is not a non-empty string.
 */
export function cased(
  input: string,
  form?: "uppercase" | "lowercase" | "capitalize",
): string {
  if (typeof input !== "string" || input.length === 0) {
    throw new Error("Input must be a non-empty string");
  }

  if (!form) return input;

  switch (form) {
    case "lowercase":
      input = input.toLowerCase();
      break;
    case "uppercase":
      input = input.toUpperCase();
      break;
    case "capitalize":
      const chunks = input.split(" ");

      if (chunks.length === 1) {
        input = cap(input);
      } else {
        const rejoin = chunks.map((chunk) => cap(chunk)).join(" ");

        input = rejoin;
      }
      break;
  }

  return input;
}

/**
 * Converts a bigint to a number.
 *
 * @param digit The bigint to be converted.
 * @returns The number equivalent of the bigint.
 * @throws {TypeError} If the input is not a valid bigint.
 * @throws {RangeError} If the resulting number overflows.
 */
export function parseDigits(digit: bigint): number {
  const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;

  if (digit > BigInt(MAX_SAFE_INTEGER)) {
    throw new RangeError("Value too large to be represented as a Number");
  }

  const parsedNumber = Number.parseInt(digit.toString(), 10);

  if (Number.isNaN(parsedNumber)) {
    throw new TypeError("Invalid input: not a valid bigint");
  }

  return parsedNumber;
}

/**
 * Concatenates the given string arguments using a dot as the separator.
 *
 * @param args The strings to be concatenated.
 * @returns The resulting string with dots separating the input strings.
 */
export function dot(...args: string[]): string {
  // Join the input strings using a dot as the separator
  return args.join(".");
}

/**
 * Converts an array of tuples into an object with keys and values corresponding
 * to the first and second elements of each tuple, respectively.
 *
 * @param entries The array of tuples to be converted.
 * @returns The resulting object with keys and values corresponding to the first
 *   and second elements of each tuple, respectively.
 */
export function from<T extends any, R extends Record<keyof T, T>>(
  entries: T[][],
): R {
  // Use Object.fromEntries() to convert the array of tuples into an object
  return Object.fromEntries(entries);
}

/**
 * Converts an iterable of key-value pairs into an object where the keys are of
 * type string and the values are of type V.
 *
 * @param entries The iterable of key-value pairs to be converted.
 * @returns The resulting object where the keys are of type string and the
 *   values are of type V.
 */
export function fromMap<K extends string, V extends any>(
  entries: IterableIterator<[K, V]>,
): { [k: string]: V } {
  // Use Object.fromEntries() to convert the iterable of key-value pairs into an object
  return Object.fromEntries<V>(entries);
}

/**
 * Checks whether a given value is not undefined or null.
 *
 * @param input The value to check.
 * @returns Whether the given value is not undefined or null.
 */
export function valuable<T>(input: T | undefined | null): input is T {
  // Check whether the given value is not undefined or null
  return input !== undefined && input !== null;
}

/**
 * Checks whether a given value is an array.
 *
 * @param list The value to check.
 * @returns Whether the given value is an array.
 */
export function isArray<T extends any>(list: T | T[]): list is T[] {
  // Check whether the given value is an array
  return Array.isArray(list);
}

/**
 * Normalizes input data into an array.
 *
 * @param list The input data to normalize.
 * @returns An array of normalized data.
 */
export function parseIterable<T extends any>(list: T | T[]): T[] {
  // If the input is already an array, return it as is
  if (isArray(list)) {
    return list;
  }

  // Otherwise, return the input wrapped in an array
  return [list];
}

/**
 * Concatenates the input string with a note separated by a pipe symbol.
 *
 * @param input - The input string to concatenate with the note.
 * @param note - The note to add after the input string.
 * @returns The concatenated string.
 */
export function orWith(input: string, note: string): string {
  return `${input} | ${note}`;
}

/**
 * Combines two strings using the '&' operator.
 *
 * @param input - The first string.
 * @param note - The second string.
 * @returns A string with both input and note separated by the '&' operator.
 */
export function andWith(input: string, note: string): string {
  return input + " & " + note;
}

/**
 * Wraps a string in opening and closing curly braces on separate lines.
 *
 * @param input - The string to wrap.
 * @returns The input string wrapped in curly braces.
 */
export function bricks(input: string): string {
  return "{\n" + input + "\n}";
}

/**
 * Wraps the given input string in a pair of opening and closing braces.
 *
 * @param input The input string to wrap.
 * @returns The input string wrapped in braces.
 */
export function braces(input: string) {
  return "{" + input + "}";
}

/**
 * Joins a list of strings into a single string.
 *
 * @param args - List of strings to join
 * @returns A single string consisting of all the input strings concatenated
 *   with a space character
 */
export function joinStrings(...args: string[]): string {
  return args.join(" ");
}

/**
 * Joins a list of strings into a single string.
 *
 * @param args - List of strings to join
 * @returns A single string consisting of all the input strings concatenated
 */
export function stackString(...args: string[]): string {
  return args.join("");
}

/**
 * Returns a string in the format "name:type" or "name:type[]" if isArray is
 * true.
 *
 * @param name - The name of the type
 * @param type - The type of the value
 * @param isArray - Whether or not the value is an array
 * @returns A string in the format "name:type" or "name:type[]" if isArray is
 *   true
 */
export function typedDef(name: string, type: string, isArray: boolean): string {
  const modifiedType = isArray ? type + cons.BRACKET : type;

  return joinStrings(name, ":", modifiedType);
}

/**
 * Surrounds the input string with double quotes.
 *
 * @param text The input string to be quoted.
 * @returns The input string surrounded by double quotes.
 */
export function quotes(text: string) {
  return `"${text}"`;
}

/**
 * Wraps a property name with a specified type notation, and adds optional
 * and/or nullable annotations if specified.
 *
 * @template S - Type options for sharing across functions.
 * @param {string} property - The name of the property to wrap with type
 *   notation.
 * @param {TypeNotation} notation - The type notation to use for the property.
 * @param {S} options - Optional settings for the type, such as whether it is
 *   nullable or optional.
 * @returns {string} The wrapped property name with type notation and any
 *   additional annotations.
 */
export function wrapType<S extends Truck.TypeOptions>(
  property: string,
  notation: TypeNotation,
  options: S,
): string {
  const ONotation = options.optional ? "?:" : ":";

  const NNotation = options.nullable
    ? orWith(notation, TypeNotation.NULL)
    : notation;

  const wrapper = joinStrings(ONotation, NNotation, cons.END);

  return property + wrapper;
}

/**
 * Wraps a property and its corresponding type in a struct type definition.
 *
 * @param {string} property - The name of the property.
 * @param {string} type - The type of the property.
 * @returns {string} A struct type definition for the property and its type.
 */
export function wrapStructType(property: string, type: string): string {
  const notation = joinStrings(property, cons.EQUALS, type);

  const wrapper = joinStrings(cons.TYPE_WORD, notation, cons.BREAK);

  return wrapper;
}

/**
 * Returns a string representing the definition of a struct property.
 *
 * @param {string} property - The name of the struct property.
 * @param {object} options - An object containing optional and nullable options.
 * @param {boolean} options.optional - If true, the property is optional.
 * @param {boolean} options.nullable - If true, the property is nullable.
 * @returns {string} A string representing the definition of the struct
 *   property.
 */
export function wrapStructDef<S extends Truck.TypeOptions>(
  property: string,
  options: S,
): string {
  const prop = cap(property);

  const ONotation = options.optional ? "?:" : ":";

  const NNotation = options.nullable ? orWith(prop, TypeNotation.NULL) : prop;

  const wrapper = joinStrings(property, ONotation, NNotation, cons.END);

  return wrapper;
}

/**
 * Returns a string that wraps an array type definition with the given property
 * name and options.
 *
 * @param property - The name of the property.
 * @param options - An object containing optional and nullable flags.
 * @returns A string representing the wrapped array type definition.
 */

export function wrapArrayDef<S extends Truck.TypeOptions>(
  property: string,
  options: S,
) {
  const cprop = cap(property);

  const ONotation = options.optional ? "?:" : ":";

  const NNotation = options.nullable
    ? orWith(cons.BRACKET, TypeNotation.NULL)
    : cons.BRACKET;

  const wrapper = joinStrings(property, ONotation, cprop, NNotation, cons.END);

  return wrapper;
}

/**
 * Returns a string representing a struct type definition in TypeScript syntax.
 *
 * @param typing - The typing of the struct, defined as a string.
 * @param options - An object containing optional and nullable flags.
 * @param distinctTypes - If true, the resulting type will not include the
 *   optional flag.
 * @returns A string representing the struct type definition.
 */
export function structType(
  typing: string,
  options: Truck.TStruct,
  distinctTypes?: boolean,
) {
  const ONotation = options.optional ? "?:" : ":";

  const NNotation =
    options.nullable && !distinctTypes
      ? orWith(bricks(typing), TypeNotation.NULL)
      : bricks(typing);

  const wrapper = joinStrings(
    distinctTypes ? cons.EMPTY : ONotation,
    NNotation,
    cons.END,
  );

  return wrapper;
}

/**
 * Creates a type notation for a list of items of a certain type.
 *
 * @param typing - The type of each item in the list.
 * @param options - An object with optional parameters for the type notation:
 *
 *   - `optional` (boolean): Whether the type is optional or not (default: `false`).
 *   - `nullable` (boolean): Whether the type is nullable or not (default: `false`).
 *   - `autoGenerateId` (object): An object with options for automatically
 *       generating an ID field for each item:
 *
 *       - `field` (string): The name of the ID field (default: `"id"`).
 *       - `strategy` (string): The strategy for generating the IDs (default:
 *               `"uuidv4"`).
 *
 * @param distinctTypes - A boolean indicating whether distinct types should be
 *   wrapped in brackets (default: `false`).
 * @returns A type notation for a list of items of the specified type.
 */
export function listType(
  typing: string,
  options: Truck.TArray,
  distinctTypes?: boolean,
) {
  const ONotation = options.optional ? "?:" : ":";

  const autoGenerateId = options.autoGenerateId;

  let modifiedTyping = typing;

  if (isOptionEnabled(autoGenerateId)) {
    const field = autoGenerateId.field ?? cons.FIELD;

    const strategy = autoGenerateId.strategy ?? cons.STRATEGY;

    let notation = TypeNotation.STRING;

    if (strategy === "autoincrement") {
      notation = TypeNotation.NUMBER;
    }

    const fieldTyping = joinStrings(field, ":", notation, cons.END);

    modifiedTyping = joinStrings(fieldTyping, modifiedTyping);
  }

  const NNotation =
    options.nullable && !distinctTypes
      ? orWith(bricks(modifiedTyping), TypeNotation.NULL)
      : bricks(modifiedTyping);

  const wrapper = joinStrings(
    distinctTypes ? cons.EMPTY : ONotation,
    NNotation,
    distinctTypes ? cons.EMPTY : cons.BRACKET,
    cons.END,
  );

  return wrapper;
}

/**
 * Generates a modified typing string with an autogenerated ID field if the
 * `autoGenerateId` option is enabled.
 *
 * @param {string} typing - The original typing string.
 * @param {Truck.ListOptions} options - The options object.
 * @returns {string} The modified typing string.
 */
export function optionsListType(
  typing: string,
  options: Truck.ListOptions,
): string {
  const autoGenerateId = options.autoGenerateId;

  let modifiedTyping = typing;

  if (isOptionEnabled(autoGenerateId)) {
    const field = autoGenerateId.field ?? cons.FIELD;

    const strategy = autoGenerateId.strategy ?? cons.STRATEGY;

    let notation = TypeNotation.STRING;

    if (strategy === "autoincrement") {
      notation = TypeNotation.NUMBER;
    }

    const fieldTyping = joinStrings(field, ":", notation, cons.END);

    modifiedTyping = joinStrings(fieldTyping, modifiedTyping);
  }

  return modifiedTyping;
}

type MapObject = { key: string; value: string };

/**
 * Converts a given object to a MapObject.
 *
 * @template T
 * @param {object} obj - The object to be converted to a MapObject.
 * @returns {MapObject} - The resulting MapObject containing the key-value pairs
 *   of the input object. The key property contains the object keys and the
 *   value property contains the object values.
 *
 * @typedef {Object} MapObject - The resulting object of the mapObject function
 *   that contains the key-value pairs of the input object.
 * @property {string} key - The object key.
 * @property {string} value - The object value.
 */
export function mapObject<T extends object>(obj: T): MapObject {
  return Object.keys(obj).reduce(
    (_p, q) => ({ key: q, value: obj[q as keyof T] } as MapObject),
    {} as MapObject,
  );
}

/**
 * Generates a TypeScript definition for a type with optional references.
 *
 * @param name - The name of the type.
 * @param type - An object containing the type definition and any references.
 * @returns A string representing the TypeScript definition.
 */
export function getType$(name: string, type: Truck.ITypeRecord) {
  let refs: string = "";

  let typenames: string[] = [name];

  for (const [key, value] of type.reference.entries()) {
    refs += joinStrings(
      cons.TYPE_WORD,
      cap(key),
      cons.EQUALS,
      value,
      cons.BREAK,
    );
    typenames.push(cap(key));
  }

  const def = joinStrings(
    cons.TYPE_WORD,
    cap(name),
    cons.EQUALS,
    bricks(type.infer),
    cons.END,
  );

  const capnames = typenames.map((name) => cap(name));

  const exp = joinStrings(
    cons.EXPORT,
    cons.TYPE_WORD,
    braces(capnames.join(",")),
  );

  return joinStrings(refs, cons.BREAK, def, cons.BREAK, exp);
}

/**
 * Generates mock data for a given model and input.
 *
 * @param m An object containing the input string, model name, and whether the
 *   model is an array or not.
 * @returns A string containing the generated mock data.
 */
export function getContent$(
  model: string,
  input: string,
  isArray: boolean,
  usetype?: boolean,
) {
  let imp = joinStrings(
    cons.IMPORT,
    braces(cap(model)),
    cons.FROM_WORD,
    quotes("./" + cons.TYPE_WORD),
    cons.END,
  );

  if (!usetype) {
    imp = cons.EMPTY;
  }

  const typeDef = typedDef(model, cap(model), isArray);

  const defExp = usetype ? typeDef : model;

  const def = joinStrings(
    cons.CONST_WORD,
    defExp,
    cons.EQUALS,
    input,
    cons.END,
  );

  const exp = joinStrings(cons.EXPORT, braces(model));

  return joinStrings(imp, cons.BREAK, def, cons.BREAK, exp);
}

export async function getApi$(model: string, isArray: boolean, args: any) {
  if (!args.server) return;

  const cname = cap(model);

  const name = stackString("get", cname, "Data");

  const type = stackString(cname, isArray ? cons.BRACKET : cons.EMPTY);

  const template = `
  import fetch from "node-fetch";
  import baseUrl from "../url";
  import {${cname}} from "./type";
  
  async function ${name}():Promise<${type}> {
    try {
      const response = await fetch(baseUrl + "${model}");
  
      const data = (await response.json()) as ${type};
  
      const ${model} = Object.assign({}, data);
  
      return ${model};
    } catch (error) {
      throw error;
    }
  }
  
  export default ${name};
  `;

  return template;
}

export function mapRoute(model: string, input: string, key: string) {
  return `  
    router.get("/___truck/${model}", (_req, res) => {
      res.setHeader("Content-Type", "application/json");
      res.setHeader("X-Truck-Key", ${quotes(key)});

      res.json(${input});
    });\n`;
}

/**
 * Compares two strings in a case-insensitive manner.
 *
 * @param {string} base - The base string to compare.
 * @param {string} target - The target string to compare.
 * @returns {boolean} - Returns true if the two strings are equal, ignoring
 *   case. Otherwise, returns false.
 */
export function compareString(base: string, target: string): boolean {
  return base.toLowerCase() === target.toLowerCase();
}

/**
 * Returns a new array with the elements of `base` that match any element in
 * `target`. Performs case-insensitive string comparison.
 *
 * @param {string[]} base - The array of strings to filter.
 * @param {string[]} target - The array of strings to compare against.
 * @returns {string[]} The filtered array of strings.
 */
export function compareAndFilter(base: string[], target: string[]): string[] {
  return base.filter((b) => target.some((t) => compareString(b, t)));
}

/**
 * Joins two strings together with an optional connector string in between.
 *
 * @param {string} first - The first string to join.
 * @param {string} second - The second string to join.
 * @param {string} [connector="_"] - The string to use as a connector between
 *   the first and second strings. Defaults to "_". Default is `"_"`
 * @returns {string} - The joined string.
 */
export function connectString(
  first: string,
  second: string,
  connector?: string,
): string {
  return joinStrings(first, connector ?? "_", second);
}

/**
 * Combines the given `options` with the `globalOptions` and returns the
 * resulting object. If neither `globalOptions` nor `options` are defined,
 * returns undefined. If only `globalOptions` is defined, returns it. If only
 * `options` is defined, returns it. If both `globalOptions` and `options` are
 * defined, merges them and returns the result.
 *
 * @param {Truck.GlobalOptions | undefined} globalOptions - The global options
 *   to merge.
 * @param {Truck.Options | undefined} options - The options to merge. The merged
 *   options, or undefined if neither `globalOptions` nor `options` are
 *   defined.
 */
export function getOptions(
  globalOptions: Truck.GlobalOptions | undefined,
  options: Truck.Options | undefined,
) {
  const isOptionsEnabled = isOptionEnabled(options);
  const isGlobalOptionsEnabled = isOptionEnabled(globalOptions);

  if (!isGlobalOptionsEnabled && !isOptionsEnabled) return;

  if (options === undefined) {
    return globalOptions;
  }

  if (globalOptions === undefined) {
    return options;
  }

  return { ...globalOptions, ...options };
}

/**
 * Determines whether to run a "clean" operation based on the provided global
 * options.
 *
 * @param {Truck.GlobalOptions} [globalOptions] - The global options to
 *   consider.
 * @returns {boolean} Whether to run a "clean" operation.
 */
export function cleaner(globalOptions?: Truck.GlobalOptions): boolean {
  let clean = true;

  if (isOptionEnabled(globalOptions)) {
    const c = globalOptions.clean;

    clean = valuable(c) ? c : true;
  }

  return clean;
}

/**
 * Check whether the useTypes option is enabled in the given options object.
 *
 * @param {Truck.GlobalOptions | Truck.Options} options - The options object to
 *   check.
 * @returns {boolean} - True if useTypes is enabled, false otherwise.
 */
export function canUseTypes(
  options: Truck.GlobalOptions | Truck.Options,
): boolean {
  let wt = true;

  if (isOptionEnabled(options)) {
    const useTypes = options.useTypes;

    wt = valuable(useTypes) ? useTypes : true;
  }

  return wt;
}

export async function format(...enteries: string[]) {
  const templates = await Promise.all(
    enteries.map(async (data) => {
      const formatted = prettier.format(data ?? "", {
        parser: "babel-ts",
      });

      return formatted;
    }),
  );

  return templates;
}
